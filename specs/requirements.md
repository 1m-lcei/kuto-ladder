# アプリケーション仕様書 (v4)

## 1. 概要
ユーザーが指定した開始ランクからランク1に至るまでの進行パス戦略を計算し、各ステップで取りうる「ランクの許容範囲」を可視化するアプリケーション。パス戦略は「効率的パス」と「試合数多いパス」の2種類から選択できる。

## 2. コアロジック
本アプリケーションの計算ロジックは、事前に計算された結果を静的なJSONファイルとしてクライアントに提供する方式を採用する。

### 2.1. 事前計算スクリプト
1.  **開発者が手動で実行するため**の事前計算スクリプトを用意する。このスクリプトは、1から15001位までの全ランクに対する「最短ステップ数」と「最長ステップ数」を計算する。
    - **最短ステップ数配列 `dist[]`**: `dist[n] = 1 + min(dist[v])`
    - **最長ステップ数配列 `steps[]`**: `steps[n] = 1 + max(steps[v])`
    (ただし `v` は `getNextRankRange(n)` の範囲内のランク)
2.  計算結果は、`dist: number[]` と `steps: number[]` という2つの配列を持つ単一のJSONファイル（例: `public/rank-data.json`）として出力する。

### 2.2. クライアントサイドの処理
1.  アプリケーションは起動時に、このJSONファイルを非同期でフェッチして読み込む。
2.  ユーザーが開始ランクを入力すると、読み込んだデータ配列を参照して、以下のロジックに基づき、瞬時にパスシーケンスを生成する。

    - **効率的パス戦略の場合:**
      1. 現在ランクを `u` とする。
      2. `getNextRankRange(u)` で得られる挑戦可能なランク `v` の中から、`dist[v] === dist[u] - 1` を満たすものを見つける。
      3. それらのランク `v` の最大値と最小値が「許容範囲」となる。
      4. 次のステップの現在ランクとして、許容範囲内の最小ランクを選択する。
      5. ランク1になるまで繰り返す。

    - **試合数多いパス戦略の場合:**
      1. 現在ランクを `u` とする。
      2. `getNextRankRange(u)` で得られる挑戦可能なランク `v` の中から、`steps[v] === steps[u] - 1` を満たすものを見つける。
      3. それらのランク `v` の最大値と最小値が「許容範囲」となる。
      4. 次のステップの現在ランクとして、許容範囲内の最大ランクを選択する。
      5. ランク1になるまで繰り返す。

## 3. データ構造
計算結果としてUIに渡されるデータは、以下の `PathStep` オブジェクトの配列 (`PathStep[]`) とする。

```ts
interface PathStep {
  // そのステップの開始ランク
  currentRank: number;
  // そのステップで次に進むことが許容されるランクの範囲 [最大ランク, 最小ランク]
  nextRankRange: [number, number];
}
```

## 4. UI/UX デザイン
- **入力:** ユーザーが開始ランクを入力する数値入力フィールド。
- **切替:** 「効率的パス」と「試合数多いパス」の表示を切り替えるための単一のチェックボックス（トグルスイッチ）。
- **可視化:**
  - 計算された `PathStep[]` に基づき、各ステップを表現するカードを縦に積み重ねて表示する。
  - 各カードには `currentRank` と `nextRankRange` の情報を明記する。（例: `8位` → 次の範囲: `5位`～`7位`）

## 5. コンポーネント構成案
- **`src/app/App.tsx`**: UIの主要部分と状態管理を担当。
- **`src/components/RankPathVisualizer.tsx`**: `PathStep[]` のデータをレンダリングする。
- **`src/utils/rankCalculator.ts`**: クライアントサイドで、読み込んだJSONデータを元にパスシーケンスを計算するロジックを実装する。
- **`scripts/precompute.ts`**: 開発者が手動で実行する、事前計算とJSON生成のためのスクリプト。